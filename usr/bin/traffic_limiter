#!/usr/bin/env python3
#
# This file is part of Traffic Limiter.
#
# Traffic Limiter is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Traffic Limiter is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Traffic Limiter. If not, see <https://www.gnu.org/licenses/>.
#

import gi
import subprocess
import sys

gi.require_version("Gtk", "4.0")
from gi.repository import Gtk, Gio, GLib


def run_command(cmd_list):
    """Wrapper to run a command via subprocess and print errors if any."""
    try:
        result = subprocess.run(cmd_list, capture_output=True, text=True)
        if result.returncode != 0:
            print(f"Error running {' '.join(cmd_list)}:\n{result.stderr.strip()}",
                  file=sys.stderr)
        return result
    except Exception as e:
        print(f"Exception running {' '.join(cmd_list)}: {e}", file=sys.stderr)
        return None


def get_tc_limit(interface):
    """Fetch only the active limiter rate."""
    result = subprocess.run(["sudo", "tc", "qdisc", "show", "dev", interface],
                            capture_output=True, text=True)
    output_lines = result.stdout.strip().split("\n")
    for line in output_lines:
        if "tbf" in line:
            parts = line.split()
            if "rate" in parts:
                rate_index = parts.index("rate") + 1
                speed = parts[rate_index]
                return f"Limiter Active: {speed}"
    return "No Limit Applied"


class TrafficLimiter(Gtk.ApplicationWindow):
    def __init__(self, app):
        super().__init__(application=app, title="TC Bandwidth Limiter")
        self.set_default_size(600, 450)

        # Define default speed unit.
        self.selected_unit = "MiB/s"

        # Main vertical container.
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        main_box.set_margin_top(10)
        main_box.set_margin_bottom(10)
        main_box.set_margin_start(10)
        main_box.set_margin_end(10)
        self.set_child(main_box)

        # ----------------------
        # Top Section: Network Interfaces
        # ----------------------
        top_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        main_box.append(top_box)

        self.info_label = Gtk.Label(label="Available Network Interfaces:")
        top_box.append(self.info_label)

        self.store = Gtk.ListStore(str, str)
        self.interface_view = Gtk.TreeView(model=self.store)
        for i, title in enumerate(["Interface", "IP Address"]):
            renderer = Gtk.CellRendererText()
            column = Gtk.TreeViewColumn(title, renderer, text=i)
            self.interface_view.append_column(column)

        scrolled_win = Gtk.ScrolledWindow()
        scrolled_win.set_child(self.interface_view)
        scrolled_win.set_min_content_height(150)
        top_box.append(scrolled_win)

        refresh_button = Gtk.Button(label="Refresh Interfaces")
        refresh_button.connect("clicked", self.populate_interfaces)
        top_box.append(refresh_button)

        # ----------------------
        # Middle Section: Speed Input & Status
        # ----------------------
        middle_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        main_box.append(middle_box)

        self.speed_label = Gtk.Label(label=f"Set Speed (in {self.selected_unit}):")
        middle_box.append(self.speed_label)

        self.speed_entry = Gtk.Entry(placeholder_text=f"e.g., 10 (in {self.selected_unit})")
        middle_box.append(self.speed_entry)

        self.status_label = Gtk.Label(label="Limiter Status: No Limit Applied")
        middle_box.append(self.status_label)

        # ----------------------
        # Bottom Section: Action Buttons and Speed Unit Buttons in a Grid
        # ----------------------
        bottom_grid = Gtk.Grid()
        bottom_grid.set_column_spacing(20)
        bottom_grid.set_row_spacing(10)
        bottom_grid.set_hexpand(True)
        main_box.append(bottom_grid)

        # Left column: Apply and Clear Buttons.
        apply_button = Gtk.Button(label="Apply Limit")
        apply_button.connect("clicked", self.apply_limit)
        bottom_grid.attach(apply_button, left=0, top=0, width=1, height=1)

        clear_button = Gtk.Button(label="Clear Limit")
        clear_button.connect("clicked", self.clear_limit)
        bottom_grid.attach(clear_button, left=0, top=1, width=1, height=1)

        # Right column: Speed Unit Buttons arranged horizontally.
        speed_unit_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        speed_unit_box.set_hexpand(True)
        speed_unit_box.set_halign(Gtk.Align.END)
        bottom_grid.attach(speed_unit_box, left=1, top=0, width=1, height=2)

        self.btn_bs = Gtk.Button(label="B/s")
        self.btn_bs.connect("clicked", self.on_speed_button_clicked, "B/s")
        speed_unit_box.append(self.btn_bs)

        self.btn_kib = Gtk.Button(label="KiB/s")
        self.btn_kib.connect("clicked", self.on_speed_button_clicked, "KiB/s")
        speed_unit_box.append(self.btn_kib)

        self.btn_mib = Gtk.Button(label="MiB/s")
        self.btn_mib.connect("clicked", self.on_speed_button_clicked, "MiB/s")
        speed_unit_box.append(self.btn_mib)

        self.update_speed_buttons()

        self.populate_interfaces()
        GLib.timeout_add_seconds(5, self.update_status)

    def on_speed_button_clicked(self, widget, unit):
        """Update the speed unit when a speed button is clicked."""
        self.selected_unit = unit
        self.speed_label.set_text(f"Set Speed (in {self.selected_unit}):")
        self.speed_entry.set_placeholder_text(f"e.g., 10 (in {self.selected_unit})")
        self.update_speed_buttons()

    def update_speed_buttons(self):
        """Append an asterisk to the active unit's label for visual feedback."""
        self.btn_bs.set_label("B/s" + (" *" if self.selected_unit == "B/s" else ""))
        self.btn_kib.set_label("KiB/s" + (" *" if self.selected_unit == "KiB/s" else ""))
        self.btn_mib.set_label("MiB/s" + (" *" if self.selected_unit == "MiB/s" else ""))

    def populate_interfaces(self, widget=None):
        """Populate the interface list from the system."""
        self.store.clear()
        result = subprocess.run(["ls", "/sys/class/net"], capture_output=True, text=True)
        interfaces = result.stdout.strip().splitlines()

        ip_result = subprocess.run(["ip", "-o", "-4", "addr", "show"],
                                   capture_output=True, text=True)
        ip_map = {}
        for line in ip_result.stdout.strip().splitlines():
            parts = line.split()
            if len(parts) >= 4:
                intf = parts[1]
                ipaddr = parts[3].split("/")[0]
                ip_map[intf] = ipaddr
        for iface in interfaces:
            ipaddr = ip_map.get(iface, "No IP Assigned")
            self.store.append([iface, ipaddr])

    def get_selected_interface(self):
        """Return the currently selected network interface."""
        selection = self.interface_view.get_selection()
        model, tree_iter = selection.get_selected()
        if tree_iter is None:
            print("No interface selected.")
            return None
        return model[tree_iter][0].strip()

    def get_speed_in_kbps(self):
        """Calculate the speed in kilobits per second based on the selected unit."""
        speed_str = self.speed_entry.get_text().strip()
        if not speed_str.isdigit():
            print("Error: Speed must be a numeric value.")
            return None
        speed = int(speed_str)
        if self.selected_unit == "MiB/s":
            return speed * 8192
        elif self.selected_unit == "KiB/s":
            return speed * 8
        elif self.selected_unit == "B/s":
            return speed // 125
        return speed

    def update_status(self):
        """Periodically update the limiter status."""
        interface = self.get_selected_interface()
        if interface:
            status_text = get_tc_limit(interface)
            self.status_label.set_text(status_text)
        return True  # Continue the timeout.

    def apply_limit(self, widget):
        interface = self.get_selected_interface()
        speed_kbps = self.get_speed_in_kbps()
        if not interface or speed_kbps is None:
            print("Invalid input.")
            return
        print(f"Applying limits: {speed_kbps} kbps on {interface}")
        upl_cmd = ["sudo", "tc", "qdisc", "add", "dev", interface, "root",
                   "tbf", "rate", f"{speed_kbps}kbit", "burst", "16kbit", "latency", "50ms"]
        run_command(upl_cmd)
        dnl_cmd = ["sudo", "tc", "qdisc", "add", "dev", interface, "ingress",
                   "tbf", "rate", f"{speed_kbps}kbit", "burst", "16kbit", "latency", "50ms"]
        run_command(dnl_cmd)
        self.update_status()

    def clear_limit(self, widget):
        interface = self.get_selected_interface()
        if not interface:
            print("No interface selected. Cannot clear limits.")
            return
        print(f"Clearing limits on {interface}.")
        run_command(["sudo", "tc", "qdisc", "del", "dev", interface, "root"])
        run_command(["sudo", "tc", "qdisc", "del", "dev", interface, "ingress"])
        self.update_status()


class TrafficApp(Gtk.Application):
    def __init__(self):
        super().__init__(application_id="com.example.TrafficLimiter",
                         flags=Gio.ApplicationFlags.FLAGS_NONE)

    def do_activate(self):
        window = TrafficLimiter(self)
        window.present()


if __name__ == "__main__":
    app = TrafficApp()
    app.run([])
