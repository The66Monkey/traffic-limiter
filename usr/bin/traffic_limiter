#!/usr/bin/env python3

#
# This file is part of Traffic Limiter.
#
# Traffic Limiter is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Traffic Limiter is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Traffic Limiter. If not, see <https://www.gnu.org/licenses/>.
#

#!/usr/bin/env python3
import gi
import subprocess
import sys

gi.require_version("Gtk", "4.0")
from gi.repository import Gtk, Gio, GLib

def run_command(cmd_list):
    """Wrapper to run a command via subprocess and print errors if any."""
    try:
        result = subprocess.run(cmd_list, capture_output=True, text=True)
        if result.returncode != 0:
            print(f"Error running {' '.join(cmd_list)}:\n{result.stderr.strip()}", file=sys.stderr)
        return result
    except Exception as e:
        print(f"Exception running {' '.join(cmd_list)}: {e}", file=sys.stderr)
        return None

def get_tc_status(interface):
    """Fetch and return the active traffic limiter details."""
    result = subprocess.run(["sudo", "tc", "qdisc", "show", "dev", interface], capture_output=True, text=True)
    return result.stdout.strip()

class TrafficLimiter(Gtk.ApplicationWindow):
    def __init__(self, app):
        super().__init__(application=app, title="TC Bandwidth Limiter")
        self.set_default_size(600, 450)

        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        self.set_child(main_box)

        # Interface label and TreeView
        self.info_label = Gtk.Label(label="Available Network Interfaces (Name & IP):")
        main_box.append(self.info_label)

        self.store = Gtk.ListStore(str, str)
        self.interface_view = Gtk.TreeView(model=self.store)
        for i, title in enumerate(["Interface", "IP Address"]):
            renderer = Gtk.CellRendererText()
            column = Gtk.TreeViewColumn(title, renderer, text=i)
            self.interface_view.append_column(column)

        scrolled_win = Gtk.ScrolledWindow()
        scrolled_win.set_child(self.interface_view)
        scrolled_win.set_vexpand(True)
        main_box.append(scrolled_win)

        refresh_button = Gtk.Button(label="Refresh Interfaces")
        refresh_button.connect("clicked", self.populate_interfaces)
        main_box.append(refresh_button)

        # Speed input section
        self.upload_label = Gtk.Label(label="Set Upload Speed (in kbps):")
        main_box.append(self.upload_label)
        self.upload_entry = Gtk.Entry(placeholder_text="e.g., 500")
        main_box.append(self.upload_entry)

        self.download_label = Gtk.Label(label="Set Download Speed (in kbps):")
        main_box.append(self.download_label)
        self.download_entry = Gtk.Entry(placeholder_text="e.g., 500")
        main_box.append(self.download_entry)

        # Status Label
        self.status_label = Gtk.Label(label="Limiter Status: Not Applied")
        main_box.append(self.status_label)

        # Buttons for applying and clearing limits
        hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        main_box.append(hbox)

        apply_button = Gtk.Button(label="Apply Limit")
        apply_button.connect("clicked", self.apply_limit)
        hbox.append(apply_button)

        clear_button = Gtk.Button(label="Clear Limit")
        clear_button.connect("clicked", self.clear_limit)
        hbox.append(clear_button)

        self.populate_interfaces()

        # Automatically refresh limiter status every 5 seconds
        GLib.timeout_add_seconds(5, self.update_status)

    def populate_interfaces(self, widget=None):
        """Populate the TreeView with interface names and IPv4 addresses."""
        self.store.clear()
        result = subprocess.run(["ls", "/sys/class/net"], capture_output=True, text=True)
        interfaces = result.stdout.strip().splitlines()

        ip_result = subprocess.run(["ip", "-o", "-4", "addr", "show"], capture_output=True, text=True)
        lines = ip_result.stdout.strip().splitlines()
        ip_map = {}
        for line in lines:
            parts = line.split()
            if len(parts) >= 4:
                intf = parts[1]
                ipaddr = parts[3].split("/")[0]
                ip_map[intf] = ipaddr

        for iface in interfaces:
            ipaddr = ip_map.get(iface, "No IP Assigned")
            self.store.append([iface, ipaddr])

    def get_selected_interface(self):
        """Return the name of the selected interface in the TreeView."""
        selection = self.interface_view.get_selection()
        model, tree_iter = selection.get_selected()
        if tree_iter is None:
            print("No interface selected.")
            return None
        selected = model[tree_iter][0].strip()
        return selected

    def update_status(self):
        """Update the status window dynamically."""
        interface = self.get_selected_interface()
        if interface:
            status_text = get_tc_status(interface)
            if status_text:
                self.status_label.set_text(f"Limiter Status: {status_text}")
            else:
                self.status_label.set_text("Limiter Status: Not Applied")
        return True  # Keeps the timer running

    def apply_limit(self, widget):
        interface = self.get_selected_interface()
        upload_speed = self.upload_entry.get_text().strip()
        download_speed = self.download_entry.get_text().strip()

        if not interface:
            print("No interface selected. Aborting Apply Limit.")
            return
        if not upload_speed.isdigit() or not download_speed.isdigit():
            print("Error: Upload and Download speeds must be numeric values.")
            return

        print(f"Applying limits on {interface}: {upload_speed} kbps upl, {download_speed} kbps dnl.")

        # Apply upload limit (egress)
        upl_cmd = ["sudo", "tc", "qdisc", "add", "dev", interface, "root",
                   "tbf", "rate", f"{upload_speed}kbit", "burst", "16kbit", "latency", "50ms"]
        run_command(upl_cmd)

        # Apply download limit (ingress)
        ing_cmd = ["sudo", "tc", "qdisc", "add", "dev", interface, "ingress"]
        run_command(ing_cmd)
        dnl_cmd = ["sudo", "tc", "qdisc", "add", "dev", interface, "root",
                   "tbf", "rate", f"{download_speed}kbit", "burst", "16kbit", "latency", "50ms"]
        run_command(dnl_cmd)

        self.update_status()
        print("Limits applied.")

    def clear_limit(self, widget):
        interface = self.get_selected_interface()
        if not interface:
            print("No interface selected. Cannot clear limits.")
            return

        print(f"Clearing limits on {interface}.")
        run_command(["sudo", "tc", "qdisc", "del", "dev", interface, "root"])
        run_command(["sudo", "tc", "qdisc", "del", "dev", interface, "ingress"])

        self.update_status()
        print("Limits cleared.")

class TrafficApp(Gtk.Application):
    def __init__(self):
        super().__init__(application_id="com.example.TrafficLimiter", flags=Gio.ApplicationFlags.FLAGS_NONE)

    def do_activate(self):
        window = TrafficLimiter(self)
        window.present()

if __name__ == "__main__":
    app = TrafficApp()
    app.run([])